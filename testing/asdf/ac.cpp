/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

/* INCLUDES */
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <queue>
#include <deque>
#include <bitset>
#include <iterator>
#include <list>
#include <stack>
#include <map>
#include <set>
#include <functional>
#include <numeric>
#include <random>
#include <utility>
#include <limits>
#include <ctime>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cassert>
using namespace std;

/* TYPES */
#define long int64_t
#define all(v) v.begin(), v.end()
typedef pair<int,int> pii;
typedef pair<int64_t,int> pli;
typedef pair<int64_t,int64_t> pll;
typedef vector<int> vi;
typedef vector<pair<int,int> > vpi;
typedef vector<string> vs;
typedef vector<vector<int> > vvi;
typedef vector<vector<int64_t> > vvl;

/* CONSTANTS */
const long MOD = 1e9+7, LINF = 1e18 + 1e16;
const int INF = 1e9+1;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

/* FUNCTIONS */
template<typename T, typename U> inline void setMin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void setMax(T &x, U y) { if(x < y) x = y; }
template<typename T>
inline T gcd(T a, T b) {
    T c;
    while(b) c = b, b = a % b, a = c;
    return a;
}
template<typename T>
inline T square(T a, T b) { return a*b; }
const int N = 1 << 17;

class ParadeDepth {

    int n, m;
    vector<int> g[N];

    int d[N];
    vector<int> anc[N];

    int tin[N], tout[N];

    void init_dfs(int u, int prev_node) {
        static int current_tick = 0;
        tin[u] = current_tick++;

        for(int v: g[u]) {
            if(v == prev_node) continue;
            d[v] = d[u] + 1;
            anc[v].push_back(u);
            for(int j = 0; 1 << j+1 <= d[v]; j++) {
                anc[v].push_back(anc[anc[v][j]][j]);
            }
            init_dfs(v, u);
        }

        tout[u] = current_tick-1;
    }

    int get_lca(int u, int v) {
        if(d[u] < d[v]) swap(u, v);
        for(int j = 0; d[u] - d[v]; j++) if(d[u] - d[v] >> j & 1)
                u = anc[u][j];
        if(u == v) return u;
        for(int j = anc[u].size()-1; j >= 0; j--)
            if(j < anc[u].size() && anc[u][j] != anc[v][j])
                u = anc[u][j], v = anc[v][j];
        return anc[u][0];
    }

    int get_anc(int v, int lvl) {
        int diff = d[v] - lvl;
        for(int j = anc[v].size()-1; j >= 0; j--) {
            if(diff >> j & 1) {
                v = anc[v][j];
            }
        }
        return v;
    }

    int get_dist(int src, int dst) {
        return d[src] + d[dst] - 2*d[get_lca(src, dst)];
    }

public:
    void solve(istream &cin, ostream &cout) {
        cin >> n >> m;
        for(int i = 1, u, v; i < n; i++) {
            cin >> u >> v;
            --u, --v;
            g[u].push_back(v);
            g[v].push_back(u);
        }

        init_dfs(0, -1);

//        for(int i = 0; i < n; i++) cerr << i+1 << ' ' << par[i] + 1 << endl;
//        cerr << endl;
//        for(int i = 0; i < n; i++) cerr << i+1 << ' ' << nxt[i]  + 1<< endl;

        for(int i = 0, x, y, p; i < m; i++) {
            cin >> x >> y >> p;
            --x, -- y, --p;
            int lca = get_lca(x, y);
            int xy_dist = get_dist(x, y);
            if(tin[lca] <= tin[p] && tin[p] <= tout[lca]) { // p is in the subtree with lca
                int l = d[lca], r = d[p];
                while(l < r) {
                    int mid = l+r+1 >> 1;
                    int v = get_anc(p, mid);
                    if(get_dist(x, v) + get_dist(v, y) == xy_dist) l = mid;
                    else r = mid - 1;
                }

                int targ_vertex = get_anc(p, l);
                cout << get_dist(p, targ_vertex) << '\n';

            } else {
                cout << get_dist(p, lca) << '\n'; // otherwise just get the distance between p and the lca
            }
        }
    }
};
// LOOK FOR INITIALIZATION BUGS (PAR, vertex 0, incomplete code, etc);
// Check reused variable names


class Solver {
public:
    void solve(std::istream& in, std::ostream& out) {
        ParadeDepth *obj = new ParadeDepth();
        obj->solve(in, out);
        delete obj;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    Solver solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
